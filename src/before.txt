#include <SFML/Graphics.hpp>
#include <SFML/Window.hpp>
#include <SFML/System.hpp>
#include <random>
#include <vector>
#include <chrono>
#include <cmath>
#include <iostream>

struct Ball {
    sf::Vector2f position;
    sf::Vector2f velocity;
    float mass;
    float radius;
    int sizeId;
    sf::Color color;
};


int main() {
    sf::ContextSettings settings;
    settings.antialiasingLevel = 8;
    unsigned int windowWidth = 2560;
    unsigned int windowHeight = 1440;
    sf::RenderWindow window(sf::VideoMode({windowWidth,windowHeight}), "Bouncing Balls Simulation", sf::Style::Default, settings);
    window.setVerticalSyncEnabled(true);

    std::vector<Ball> balls;
    std::vector<Ball> removedBalls;
    std::vector<int> sizes = {10, 25, 45, 60, 80};
    int numBalls = 185;
    balls.reserve(195);

    srand(static_cast<unsigned int>(time(0)));
    for (int i = 0; i < numBalls; ++i) {
        Ball ball;
        ball.position = {static_cast<float>(rand() % (windowWidth-40) + 40), static_cast<float>(rand() % (windowHeight-40) + 40)};
        ball.velocity = {static_cast<float>(rand() % 200 - 100), static_cast<float>(rand() % 200 - 100)};
        ball.sizeId = static_cast<float>(rand() % 3);
        ball.radius = sizes[ball.sizeId];
        // ball.mass = pow(ball.radius, 2) * 3.14f * 2;
        ball.mass = 1;
        ball.color = sf::Color(rand() % 256, rand() % 256, rand() % 256);
        balls.push_back(ball);
    }

    sf::Clock clock;
    float dt;
    const sf::Vector2f g = {0.f, 981.f};
    float bounceDamp = 0.84f;
    float linearDamp = 0.001f;
    const float OFFSET = 0.0001f;
    const float MIN_SEP = 0.01f;  // Minimum separation threshold
    const float POS_COR = 0.6f;  // Position correction factor


    while (window.isOpen())
    {
        dt = clock.restart().asSeconds();
        const float MAX_DT = 1.0f/60.0f;  // Cap at 60 FPS
        dt = std::min(dt, MAX_DT);

        sf::Event event;
        while (window.pollEvent(event))
        {
            if (event.type == sf::Event::Closed)
                window.close();
            
            if (event.type == sf::Event::MouseButtonPressed && event.mouseButton.button == sf::Mouse::Left){
                std::cout << sf::Mouse::getPosition(window).x << ", " << sf::Mouse::getPosition(window).y << std::endl;
            }
        }

        // --- Updated: separate integration and collision resolution using flags ---
        std::vector<char> removed(balls.size(), 0);

        // 1) Integrate motion and handle wall collisions
        for (size_t i = 0; i < balls.size(); ++i) {
            Ball& ball = balls[i];
            ball.velocity += g * dt;
            ball.position += ball.velocity * dt;
            ball.velocity -= ball.velocity * linearDamp;

            // Floor
            if (ball.position.y + ball.radius > windowHeight - OFFSET) {
                ball.position.y = windowHeight - ball.radius - OFFSET;
                ball.velocity.y = (-ball.velocity.y) * bounceDamp;
                if (std::abs(ball.velocity.y) < 0.0001f) ball.velocity.y = 0;
                if (std::abs(ball.velocity.x) < 0.0001f) ball.velocity.x = 0;
            }
            // Ceiling
            if (ball.position.y - ball.radius < 0 + OFFSET) {
                ball.position.y = 0 + ball.radius + OFFSET;
                ball.velocity.y = (-ball.velocity.y) * bounceDamp;
            }
            // Right wall
            if (ball.position.x + ball.radius > windowWidth - OFFSET) {
                ball.position.x = windowWidth - ball.radius - OFFSET;
                ball.velocity.x = (-ball.velocity.x) * bounceDamp;
            }
            // Left wall
            if (ball.position.x - ball.radius < 0 + OFFSET) {
                ball.position.x = 0 + ball.radius + OFFSET;
                ball.velocity.x = (-ball.velocity.x) * bounceDamp;
            }
        }

        // 2) Collision resolution (each pair once), mark removals in 'removed'
        for (size_t i = 0; i < balls.size(); ++i) {
            if (removed[i]) continue;
            for (size_t j = i + 1; j < balls.size(); ++j) {
                if (removed[j]) continue;

                Ball &b1 = balls[i];
                Ball &b2 = balls[j];

                sf::Vector2f diff = b1.position - b2.position;
                float distSq = diff.x * diff.x + diff.y * diff.y;
                float dist = std::sqrt(distSq);
                float overlap = (b1.radius + b2.radius) - dist;

                if (overlap > MIN_SEP) {
                    // handle merge when same sizeId
                    if (b1.sizeId == b2.sizeId) {
                        // increase size of b1 up to max
                        if (b1.sizeId + 1 < static_cast<int>(sizes.size())) {
                            b1.sizeId++;
                            b1.radius = sizes[b1.sizeId];
                        }
                        removed[j] = 1; // mark b2 for removal
                        continue;
                    }

                    // prevent division by zero
                    sf::Vector2f normal = (dist > 0.0f) ? (diff / dist) : sf::Vector2f(1.f, 0.f);

                    float totalMass = b1.mass + b2.mass;
                    float ratio1 = b1.mass / totalMass;
                    float ratio2 = b2.mass / totalMass;

                    // positional correction
                    b1.position += normal * overlap * ratio2 * POS_COR;
                    b2.position -= normal * overlap * ratio1 * POS_COR;

                    // relative velocity along normal
                    float relVel = (b1.velocity.x - b2.velocity.x) * normal.x + (b1.velocity.y - b2.velocity.y) * normal.y;
                    if (relVel > 0) continue;

                    float jimp = -(1.f + bounceDamp) * relVel;
                    jimp /= (1.f / b1.mass) + (1.f / b2.mass);

                    sf::Vector2f impulse = jimp * normal;
                    b1.velocity += impulse / b1.mass;
                    b2.velocity -= impulse / b2.mass;
                }
            }
        }

        // compact removed balls (one pass)
        bool anyRemoved = std::any_of(removed.begin(), removed.end(), [](char c){ return c != 0; });
        if (anyRemoved) {
            std::vector<Ball> compacted;
            compacted.reserve(balls.size());
            for (size_t i = 0; i < balls.size(); ++i) {
                if (!removed[i]) compacted.push_back(std::move(balls[i]));
            }
            balls.swap(compacted);
        }
        // --- end updated section ---

        //draw stuff here
        window.clear(sf::Color::Black);
        for (const auto& ball : balls) {
            sf::CircleShape circle(ball.radius);
            circle.setFillColor(sf::Color::Blue);
            circle.setPosition(ball.position - sf::Vector2f(ball.radius, ball.radius));
            window.draw(circle);
        }
        window.display();


    }
    return 0;
}


